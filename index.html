

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>pykalman &mdash; pykalman 0.9.0 documentation</title>
    
    <link rel="stylesheet" href="_static/default.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '0.9.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="top" title="pykalman 0.9.0 documentation" href="#" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li><a href="#">pykalman 0.9.0 documentation</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1><a class="reference external" href="https://github.com/pykalman/pykalman">pykalman</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>Welcome to <a class="reference external" href="https://github.com/pykalman/pykalman">pykalman</a>, the dead-simple Kalman Filter, Kalman Smoother, and EM library for Python:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pykalman</span> <span class="kn">import</span> <span class="n">KalmanFilter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kf</span> <span class="o">=</span> <span class="n">KalmanFilter</span><span class="p">(</span><span class="n">transition_matrices</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">observation_matrices</span> <span class="o">=</span> <span class="p">[[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">],</span> <span class="p">[</span><span class="o">-</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">measurements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]])</span>  <span class="c"># 3 observations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kf</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="n">em</span><span class="p">(</span><span class="n">measurements</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">filtered_state_means</span><span class="p">,</span> <span class="n">filtered_state_covariances</span><span class="p">)</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">measurements</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">smoothed_state_means</span><span class="p">,</span> <span class="n">smoothed_state_covariances</span><span class="p">)</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">measurements</span><span class="p">)</span>
</pre></div>
</div>
<p>Also included is support for missing measurements:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">measurements</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">measurements</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">measurements</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked</span>   <span class="c"># measurement at timestep 1 is unobserved</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kf</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="n">em</span><span class="p">(</span><span class="n">measurements</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">filtered_state_means</span><span class="p">,</span> <span class="n">filtered_state_covariances</span><span class="p">)</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">measurements</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="p">(</span><span class="n">smoothed_state_means</span><span class="p">,</span> <span class="n">smoothed_state_covariances</span><span class="p">)</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">measurements</span><span class="p">)</span>
</pre></div>
</div>
<p>And for the non-linear dynamics via the <tt class="xref py py-class docutils literal"><span class="pre">UnscentedKalmanFilter</span></tt>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">I</span><span class="s">&#39;ll fill this in someday...</span>
</pre></div>
</div>
<div class="section" id="installation">
<h2>Installation<a class="headerlink" href="#installation" title="Permalink to this headline">¶</a></h2>
<p>For a quick installation:</p>
<div class="highlight-python"><pre>$ easy_install pykalman</pre>
</div>
<p><tt class="xref py py-mod docutils literal"><span class="pre">pykalman</span></tt> depends on the following modules,</p>
<ul class="simple">
<li><tt class="xref py py-mod docutils literal"><span class="pre">numpy</span></tt>     (for core functionality)</li>
<li><tt class="xref py py-mod docutils literal"><span class="pre">scipy</span></tt>     (for core functionality)</li>
<li><tt class="xref py py-mod docutils literal"><span class="pre">Sphinx</span></tt>    (for generating documentation)</li>
<li><tt class="xref py py-mod docutils literal"><span class="pre">numpydoc</span></tt>  (for generating documentation)</li>
<li><tt class="xref py py-mod docutils literal"><span class="pre">nose</span></tt>      (for running tests)</li>
</ul>
<p>All of these and <tt class="xref py py-mod docutils literal"><span class="pre">pykalman</span></tt> can be installed using <tt class="docutils literal"><span class="pre">easy_install</span></tt>:</p>
<div class="highlight-python"><pre>$ easy_install numpy scipy Sphinx numpydoc nose pykalman</pre>
</div>
<p>Alternatively, you can get the latest and greatest from <a class="reference external" href="https://github.com/pykalman/pykalman">github</a>:</p>
<div class="highlight-python"><pre>$ git clone git@github.com:pykalman/pykalman.git pykalman
$ cd pykalman
$ sudo python setup.py install</pre>
</div>
</div>
<div class="section" id="user-s-guide">
<h2>User&#8217;s Guide<a class="headerlink" href="#user-s-guide" title="Permalink to this headline">¶</a></h2>
<p>The Kalman Filter is a unsupervised algorithm for tracking a single object in a
continuous state space.  Given a sequence of noisy measurements, the Kalman
Filter is able to recover the &#8220;true state&#8221; of the underling object being
tracked. Common uses for the Kalman Filter include radar and sonar tracking and
state estimation in robotics.</p>
<p>The advantages of Kalman Filter are:</p>
<blockquote>
<div><ul class="simple">
<li>No need to provide labeled training data</li>
<li>Ability to handle noisy observations</li>
</ul>
</div></blockquote>
<p>The disadvantages are:</p>
<blockquote>
<div><ul class="simple">
<li>Computational complexity is cubic in the size of the state space</li>
<li>Parameter optimization is non-convex and can thus only find local optima</li>
<li>Inability to cope with non-Gaussian noise</li>
</ul>
</div></blockquote>
<div class="section" id="basic-usage">
<h3>Basic Usage<a class="headerlink" href="#basic-usage" title="Permalink to this headline">¶</a></h3>
<p>This module implements two algorithms for tracking: the Kalman Filter and
Kalman Smoother.  In addition, model parameters which are traditionally
specified by hand can also be learned by the implemented EM algorithm without
any labeled training data.  All three algorithms are contained in the
<a class="reference internal" href="#pykalman.KalmanFilter" title="pykalman.KalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">KalmanFilter</span></tt></a> class in this module.</p>
<p>In order to apply the Kalman Smoother, one need only specify the size of the
state and observation space.  This can be done directly by setting
<tt class="xref py py-attr docutils literal"><span class="pre">n_dim_state</span></tt> or <tt class="xref py py-attr docutils literal"><span class="pre">n_dim_obs</span></tt> or indirectly by specifying an initial
value for any of the model parameters from which the former can be derived:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">pykalman</span> <span class="kn">import</span> <span class="n">KalmanFilter</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kf</span> <span class="o">=</span> <span class="n">KalmanFilter</span><span class="p">(</span><span class="n">initial_state_mean</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n_dim_obs</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>The traditional Kalman Filter assumes that model parameters are known
beforehand.  The <a class="reference internal" href="#pykalman.KalmanFilter" title="pykalman.KalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">KalmanFilter</span></tt></a> class however can learn parameters using
<a class="reference internal" href="#pykalman.KalmanFilter.em" title="pykalman.KalmanFilter.em"><tt class="xref py py-func docutils literal"><span class="pre">KalmanFilter.em()</span></tt></a> (fitting is optional).  Then the hidden sequence of
states can be predicted using <a class="reference internal" href="#pykalman.KalmanFilter.smooth" title="pykalman.KalmanFilter.smooth"><tt class="xref py py-func docutils literal"><span class="pre">KalmanFilter.smooth()</span></tt></a>:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">measurements</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kf</span><span class="o">.</span><span class="n">em</span><span class="p">(</span><span class="n">measurements</span><span class="p">)</span><span class="o">.</span><span class="n">smooth</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]])</span>
<span class="go">array([[ 0.85819709],</span>
<span class="go">       [ 1.77811829],</span>
<span class="go">       [ 2.19537816]])</span>
</pre></div>
</div>
<p>The Kalman Filter is parameterized by 3 arrays for state transitions, 3 for
measurements, and 2 more for initial conditions.  Their names and function are
described in the next section.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">examples/standard/plot_sin.py</span></tt></dt>
<dd>Tracking a sine signal</dd>
</dl>
</div>
<div class="section" id="choosing-parameters">
<h4>Choosing Parameters<a class="headerlink" href="#choosing-parameters" title="Permalink to this headline">¶</a></h4>
<p>Unlike most other algorithms, the Kalman Filter and Kalman Smoother are
traditionally used with parameters already given. The <a class="reference internal" href="#pykalman.KalmanFilter" title="pykalman.KalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">KalmanFilter</span></tt></a>
class can thus be initialized with any subset of the usual model parameters and
used without fitting. Sensible defaults values are given for all unspecified
parameters (zeros for all 1-dimensional arrays and identity matrices for all
2-dimensional arrays).</p>
<p>A Kalman Filter/Smoother is fully specified by its initial conditions
(<tt class="xref py py-attr docutils literal"><span class="pre">initial_state_mean</span></tt> and <tt class="xref py py-attr docutils literal"><span class="pre">initial_state_covariance</span></tt>), its
transition parameters (<tt class="xref py py-attr docutils literal"><span class="pre">transition_matrices</span></tt>, <tt class="xref py py-attr docutils literal"><span class="pre">transition_offsets</span></tt>,
<tt class="xref py py-attr docutils literal"><span class="pre">transition_covariance</span></tt>), and its observation parameters
(<tt class="xref py py-attr docutils literal"><span class="pre">observation_matrices</span></tt>, <tt class="xref py py-attr docutils literal"><span class="pre">observation_offsets</span></tt>,
<tt class="xref py py-attr docutils literal"><span class="pre">observation_covariance</span></tt>). These parameters define a probabilistic model
from which the unobserved states and observed measurements are assumed to be
sampled from. The following code illustrates in one dimension what this process
is.</p>
<div class="highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_timesteps</span><span class="p">,</span> <span class="n">n_dim_state</span><span class="p">))</span>
<span class="n">measurements</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">n_timesteps</span><span class="p">,</span> <span class="n">n_dim_obs</span><span class="p">))</span>
<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_timesteps</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
   <span class="k">if</span> <span class="n">t</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
      <span class="n">states</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">initial_state_mean</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">initial_state_covariance</span><span class="p">))</span>
      <span class="n">measurements</span><span class="p">[</span><span class="n">t</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
          <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">observation_matrices</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">states</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
          <span class="o">+</span> <span class="n">observation_offsets</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
          <span class="o">+</span> <span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">observation_covariance</span><span class="p">))</span>
      <span class="p">)</span>
  <span class="n">states</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
      <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">transition_matrices</span><span class="p">[</span><span class="n">t</span><span class="p">],</span> <span class="n">states</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
      <span class="o">+</span> <span class="n">transition_offsets</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
      <span class="o">+</span> <span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">transition_covariance</span><span class="p">))</span>
  <span class="p">)</span>
  <span class="n">measurements</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
      <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">observation_matrices</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="n">states</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
      <span class="o">+</span> <span class="n">observation_offsets</span><span class="p">[</span><span class="n">t</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
      <span class="o">+</span> <span class="n">norm</span><span class="o">.</span><span class="n">rvs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">observation_covariance</span><span class="p">))</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>The selection of these variables is not an easy one, and, as shall be explained
in the section on fitting, should not be left to <a class="reference internal" href="#pykalman.KalmanFilter.em" title="pykalman.KalmanFilter.em"><tt class="xref py py-func docutils literal"><span class="pre">KalmanFilter.em()</span></tt></a>
alone. If one ignores the random noise, the parameters dictate that <em>the next
state and the current measurement should be an affine function of the current
state</em>. The additive noise term is then simply a way to deal with unaccounted
error.</p>
<p>A simple example to illustrate the model parameters is a free falling ball in
one dimension. The state vector can be represented by the position, velocity,
and acceleration of the ball, and the transition matrix is defined by the
equation:</p>
<div class="highlight-python"><pre>position[t+dt] = position[t] + velocity[t] dt + 0.5 acceleration[t] dt^2</pre>
</div>
<p>Taking the zeroth, first, and second derivative of the above equation with
respect to <cite>dt</cite> gives the rows of transition matrix. We may also set the
transition offset to zero for the position and velocity components and -9.8
for the acceleration component in order to account for gravity&#8217;s pull.</p>
<p>It is often very difficult to guess what appropriate values are for for the
transition and observation covariance, so it is common to use some constant
multiplied by the identity matrix. Increasing this constant is equivalent to
saying you believe there is more noise in the system. This constant is the
amount of variance you expect to see along each dimensiona during state
transitions and measurements, respectively.</p>
</div>
<div class="section" id="inferring-states">
<h4>Inferring States<a class="headerlink" href="#inferring-states" title="Permalink to this headline">¶</a></h4>
<p>The <a class="reference internal" href="#pykalman.KalmanFilter" title="pykalman.KalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">KalmanFilter</span></tt></a> class comes equipped with two algorithms for
prediction: the Kalman Filter and the Kalman Smoother. While the former can be
updated recursively (making it ideal for online state estimation), the latter
can only be done in batch. These two algorithms are accessible via
<a class="reference internal" href="#pykalman.KalmanFilter.filter" title="pykalman.KalmanFilter.filter"><tt class="xref py py-func docutils literal"><span class="pre">KalmanFilter.filter()</span></tt></a>, <a class="reference internal" href="#pykalman.KalmanFilter.filter_update" title="pykalman.KalmanFilter.filter_update"><tt class="xref py py-func docutils literal"><span class="pre">KalmanFilter.filter_update()</span></tt></a>, and
<a class="reference internal" href="#pykalman.KalmanFilter.smooth" title="pykalman.KalmanFilter.smooth"><tt class="xref py py-func docutils literal"><span class="pre">KalmanFilter.smooth()</span></tt></a>.</p>
<p>Functionally, Kalman Smoother should always be preferred. Unlike the Kalman
Filter, the Smoother is able to incorporate &#8220;future&#8221; measurements as well as
past ones at the same computational cost of <img class="math" src="_images/math/77e9ea2c9bbe43c55f59ad878ce5701eaf47594c.png" alt="O(Td^3)"/> where <img class="math" src="_images/math/2554b6496c3b678897e9b060ef00aa9f0a7d7ece.png" alt="T"/> is
the number of time steps and <cite>d</cite> is the dimensionality of the state space. The
only reason to prefer the Kalman Filter over the Smoother is in its ability to
incorporate new measurements in an online manner:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">means</span><span class="p">,</span> <span class="n">covariances</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="n">filter</span><span class="p">(</span><span class="n">measurements</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">next_mean</span><span class="p">,</span> <span class="n">next_covariance</span> <span class="o">=</span> <span class="n">kf</span><span class="o">.</span><span class="n">filter_update</span><span class="p">(</span>
<span class="go">    means[-1], covariances[-1], new_measurement</span>
<span class="go">)</span>
</pre></div>
</div>
<p>Both the Kalman Filter and Kalman Smoother are able to use parameters which
vary with time.  In order to use this, one need only pass in an array
<tt class="xref py py-attr docutils literal"><span class="pre">n_timesteps</span></tt> in length along its first axis:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">transition_offsets</span> <span class="o">=</span> <span class="p">[[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kf</span> <span class="o">=</span> <span class="n">KalmanFilter</span><span class="p">(</span><span class="n">transition_offsets</span><span class="o">=</span><span class="n">transition_offsets</span><span class="p">,</span> <span class="n">n_dim_obs</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">examples/standard/plot_online.py</span></tt></dt>
<dd>Online State Estimation</dd>
<dt><tt class="docutils literal"><span class="pre">examples/standard/plot_filter.py</span></tt></dt>
<dd>Filtering and Smoothing</dd>
</dl>
</div>
</div>
<div class="section" id="optimizing-parameters">
<h4>Optimizing Parameters<a class="headerlink" href="#optimizing-parameters" title="Permalink to this headline">¶</a></h4>
<p>In addition to the Kalman Filter and Kalman Smoother, the <a class="reference internal" href="#pykalman.KalmanFilter" title="pykalman.KalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">KalmanFilter</span></tt></a>
class implements the Expectation-Maximization algorithm. This iterative
algorithm is a way to maximize the likelihood of the observed measurements
(recall the probabilistic model induced by the model parameters), which is
unfortunately a non-convex optimization problem. This means that even when the
EM algorithm converges, there is no guarantee that it has converged to an
optimal value. Thus it is important to select good initial parameter values.</p>
<p>A second consideration when using the EM algorithm is that the algorithm lacks
regularization, meaning that parameter values may diverge to infinity in order
to make the measurements more likely. Thus it is important to choose <em>which</em>
parameters to optimize via the <tt class="xref py py-attr docutils literal"><span class="pre">em_vars</span></tt> parameter of
<a class="reference internal" href="#pykalman.KalmanFilter" title="pykalman.KalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">KalmanFilter</span></tt></a>.  For example, in order to only optimize the transition
and observation covariance matrices, one may instantiate <a class="reference internal" href="#pykalman.KalmanFilter" title="pykalman.KalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">KalmanFilter</span></tt></a>
like so:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">kf</span> <span class="o">=</span> <span class="n">KalmanFilter</span><span class="p">(</span><span class="n">em_vars</span><span class="o">=</span><span class="p">[</span><span class="s">&#39;transition_covariance&#39;</span><span class="p">,</span> <span class="s">&#39;observation_covariance&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>It is customary optimize only the <tt class="xref py py-attr docutils literal"><span class="pre">transition_covariance</span></tt>,
<tt class="xref py py-attr docutils literal"><span class="pre">observation_covariance</span></tt>, <tt class="xref py py-attr docutils literal"><span class="pre">initial_state_mean</span></tt>, and
<tt class="xref py py-attr docutils literal"><span class="pre">initial_state_covariance</span></tt>, which is the default when <tt class="xref py py-attr docutils literal"><span class="pre">em_vars</span></tt> is
unspecified. In order to avoid overfitting, it is also possible to specify the
number of iterations of the EM algorithm to run during fitting:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="n">kf</span><span class="o">.</span><span class="n">em</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">n_iter</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
</pre></div>
</div>
<p>Each iteration of the EM algorithm requires running the Kalman Smoother anew,
so its computational complexity is <img class="math" src="_images/math/5c2c8b09d6001e11048094aa1d3329335d13af82.png" alt="O(Tnd^3)"/> where <img class="math" src="_images/math/2554b6496c3b678897e9b060ef00aa9f0a7d7ece.png" alt="T"/> is the
number of time steps, <cite>n</cite> is the number of iterations, and <cite>d</cite> is the size of
the state space.</p>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">examples/standard/plot_em.py</span></tt></dt>
<dd>Using the EM Algorithm</dd>
</dl>
</div>
</div>
<div class="section" id="missing-measurements">
<h4>Missing Measurements<a class="headerlink" href="#missing-measurements" title="Permalink to this headline">¶</a></h4>
<p>In real world systems, it is common to have sensors occasionally fail.  The
Kalman Filter, Kalman Smoother, and EM algorithm are all equipped to handle
this scenario. To make use of it, one only need apply a NumPy mask to the
measurement at the missing time step:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ma</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">X</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ma</span><span class="o">.</span><span class="n">masked</span>  <span class="c"># hide measurement at time step 1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kf</span><span class="o">.</span><span class="n">em</span><span class="p">(</span><span class="n">X</span><span class="p">)</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-see-also admonition seealso">
<p class="first admonition-title">See also</p>
<dl class="last docutils">
<dt><tt class="docutils literal"><span class="pre">examples/standard/plot_missing.py</span></tt></dt>
<dd>State Estimation with Missing Observations</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="mathematical-formulation">
<h3>Mathematical Formulation<a class="headerlink" href="#mathematical-formulation" title="Permalink to this headline">¶</a></h3>
<p>In order to understand when the algorithms in this module will be effective, it
is important to understand what assumptions are being made.  To make notation
concise,  we refer to the hidden states as <img class="math" src="_images/math/4485828f5a19c01ef573976d83d057fa840ed1e3.png" alt="x_t"/>, the measurements as
<img class="math" src="_images/math/b765f0ca971f172e2f7db7e9a87d8601379b694d.png" alt="z_t"/>, and the parameters of the <a class="reference internal" href="#pykalman.KalmanFilter" title="pykalman.KalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">KalmanFilter</span></tt></a> class as follows,</p>
<blockquote>
<div><table border="1" class="docutils">
<colgroup>
<col width="61%" />
<col width="39%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Parameter Name</td>
<td>Notation</td>
</tr>
<tr class="row-even"><td><cite>initial_state_mean</cite></td>
<td><img class="math" src="_images/math/7548319dd93c27598143e27cd09522e0c727ef4f.png" alt="\mu_0"/></td>
</tr>
<tr class="row-odd"><td><cite>initial_state_covariance</cite></td>
<td><img class="math" src="_images/math/dcb56c9df837b86187e9c66311089e2e08be8308.png" alt="\Sigma_0"/></td>
</tr>
<tr class="row-even"><td><cite>transition_matrices</cite></td>
<td><img class="math" src="_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/></td>
</tr>
<tr class="row-odd"><td><cite>transition_offsets</cite></td>
<td><img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/></td>
</tr>
<tr class="row-even"><td><cite>transition_covariance</cite></td>
<td><img class="math" src="_images/math/9866e3a998d628ba0941eb4fea0666ac391d149a.png" alt="Q"/></td>
</tr>
<tr class="row-odd"><td><cite>observation_matrices</cite></td>
<td><img class="math" src="_images/math/c3355896da590fc491a10150a50416687626d7cc.png" alt="C"/></td>
</tr>
<tr class="row-even"><td><cite>observation_offsets</cite></td>
<td><img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/></td>
</tr>
<tr class="row-odd"><td><cite>observation_covariance</cite></td>
<td><img class="math" src="_images/math/eff43e84f8a3bcf7b6965f0a3248bc4d3a9d0cd4.png" alt="R"/></td>
</tr>
</tbody>
</table>
</div></blockquote>
<p>In words, the Linear-Gaussian model assumes that for all time steps <img class="math" src="_images/math/6f19c7e63a78dad1620141f9f502d0304be25206.png" alt="t =
0, \ldots, T-1"/> (here, <img class="math" src="_images/math/2554b6496c3b678897e9b060ef00aa9f0a7d7ece.png" alt="T"/> is the number of time steps),</p>
<ul class="simple">
<li><img class="math" src="_images/math/17f1249ad95b7682b8316ad21de8ce4ee9fdcf93.png" alt="x_0"/> is distributed according to a Gaussian distribution</li>
<li><img class="math" src="_images/math/a6b9e71b0be39a781fd2c9a222e556af1980d43a.png" alt="x_{t+1}"/> is an affine transformation of <img class="math" src="_images/math/4485828f5a19c01ef573976d83d057fa840ed1e3.png" alt="x_t"/> and additive
Gaussian noise</li>
<li><img class="math" src="_images/math/768e49b100713b44862cafb313c32dc47cec6bd6.png" alt="z_{t}"/> is an affine transformation of <img class="math" src="_images/math/63f40b9b3ce334f3b88199e6757727c87ae895d1.png" alt="x_{t}"/> and additive
Gaussian noise</li>
</ul>
<p>These assumptions imply that that <img class="math" src="_images/math/4485828f5a19c01ef573976d83d057fa840ed1e3.png" alt="x_t"/> is always a Gaussian
distribution, even when <img class="math" src="_images/math/b765f0ca971f172e2f7db7e9a87d8601379b694d.png" alt="z_t"/> is observed.  If this is the case, the
distribution of <img class="math" src="_images/math/7c68ae5d0baf4bf3428ff734db58a0b5d9b8ed52.png" alt="x_t|z_{1:t}"/> and <img class="math" src="_images/math/ca08676a2d3d785441fee907ed9df94c0b2ace3e.png" alt="x_t | z_{1:T-1}"/> are completely
specified by the parameters of the Gaussian distribution, namely its <em>mean</em> and
<em>covariance</em>.  The Kalman Filter and Kalman Smoother calculate these values,
respectively.</p>
<p>Formally, the Linear-Gaussian Model assumes that states and measurements are
generated in the following way,</p>
<div class="math">
<p><img src="_images/math/5f313ca97065300a6e54e13b4990272beb0b6336.png" alt="x_0               &amp; \sim \text{Gaussian}(\mu_0, \Sigma_0)   \\
x_{t+1}           &amp; = A_t x_t + b_t + \epsilon_{t+1}^{1}    \\
y_{t}             &amp; = C_t x_t + d_t + \epsilon_{t}^2        \\
\epsilon_t^1      &amp; \sim \text{Gaussian}(0, Q)              \\
\epsilon_{t}^2    &amp; \sim \text{Gaussian}(0, R)"/></p>
</div><p>The Gaussian distribution is characterized by its single mode and exponentially
decreasing tails, meaning that the Kalman Filter and Kalman Smoother work best
if one is able to guess fairly well the vicinity of the next state given the
present, but cannot say <em>exactly</em> where it will be.  On the other hand, these
methods will fail if there are multiple, disconnected areas where the next
state could be, such as if a car turns one of three ways at an intersection.</p>
<div class="topic">
<p class="topic-title first">References:</p>
<ul class="simple">
<li>Abbeel, Pieter. &#8220;Maximum Likelihood, EM&#8221;.
<a class="reference external" href="http://www.cs.berkeley.edu/~pabbeel/cs287-fa11/">http://www.cs.berkeley.edu/~pabbeel/cs287-fa11/</a></li>
<li>Yu, Byron M. and Shenoy, Krishna V. and Sahani, Maneesh. &#8220;Derivation of
Kalman Filtering and Smoothing Equations&#8221;.
<a class="reference external" href="http://www.ece.cmu.edu/~byronyu/papers/derive_ks.pdf">http://www.ece.cmu.edu/~byronyu/papers/derive_ks.pdf</a></li>
<li>Ghahramani, Zoubin and Hinton, Geoffrey E. &#8220;Parameter Estimation for
Linear Dynamical Systems.&#8221;
<a class="reference external" href="http://mlg.eng.cam.ac.uk/zoubin/course04/tr-96-2.pdf">http://mlg.eng.cam.ac.uk/zoubin/course04/tr-96-2.pdf</a></li>
<li>Welling, Max. &#8220;The Kalman Filter&#8221;.
<a class="reference external" href="http://www.cs.toronto.edu/~welling/classnotes/papers_class/KF.ps.gz">http://www.cs.toronto.edu/~welling/classnotes/papers_class/KF.ps.gz</a></li>
</ul>
</div>
</div>
</div>
<div class="section" id="class-reference">
<h2>Class Reference<a class="headerlink" href="#class-reference" title="Permalink to this headline">¶</a></h2>
<div class="section" id="kalmanfilter">
<h3><a class="reference internal" href="#pykalman.KalmanFilter" title="pykalman.KalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">KalmanFilter</span></tt></a><a class="headerlink" href="#kalmanfilter" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pykalman.KalmanFilter">
<em class="property">class </em><tt class="descclassname">pykalman.</tt><tt class="descname">KalmanFilter</tt><big>(</big><em>transition_matrices=None, observation_matrices=None, transition_covariance=None, observation_covariance=None, transition_offsets=None, observation_offsets=None, initial_state_mean=None, initial_state_covariance=None, random_state=None, em_vars=['transition_covariance', 'observation_covariance', 'initial_state_mean', 'initial_state_covariance'], n_dim_state=None, n_dim_obs=None</em><big>)</big><a class="headerlink" href="#pykalman.KalmanFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the Kalman Filter, Kalman Smoother, and EM algorithm.</p>
<p>This class implements the Kalman Filter, Kalman Smoother, and EM Algorithm
for a Linear Gaussian model specified by,</p>
<div class="math">
<p><img src="_images/math/0acb86420c5b68be3fba508e5d40bb20110c31d0.png" alt="x_{t+1}   &amp;= A_{t} x_{t} + b_{t} + \text{Normal}(0, Q_{t}) \\
z_{t}     &amp;= C_{t} x_{t} + d_{t} + \text{Normal}(0, R_{t})"/></p>
</div><p>The Kalman Filter is an algorithm designed to estimate
<img class="math" src="_images/math/71365d1512fa75e09e5b14fb09ce5f56778a601b.png" alt="P(x_t | z_{0:t})"/>.  As all state transitions and observations are
linear with Gaussian distributed noise, these distributions can be
represented exactly as Gaussian distributions with mean
<cite>filtered_state_means[t]</cite> and covariances <cite>filtered_state_covariances[t]</cite>.</p>
<p>Similarly, the Kalman Smoother is an algorithm designed to estimate
<img class="math" src="_images/math/223c6c8c7f0ef1c8476d6e05dd1e43973b09d02a.png" alt="P(x_t | z_{0:T-1})"/>.</p>
<p>The EM algorithm aims to find for
<img class="math" src="_images/math/65b5ab1ced3ea482e113bb31448f82865ff0c559.png" alt="\theta = (A, b, C, d, Q, R, \mu_0, \Sigma_0)"/></p>
<div class="math">
<p><img src="_images/math/a63de642c7dd6d260301cc0944941354cf4d0357.png" alt="\max_{\theta} P(z_{0:T-1}; \theta)"/></p>
</div><p>If we define <img class="math" src="_images/math/cbffcb2adbdf2a7340352e3e1ba44070011e9643.png" alt="L(x_{0:T-1},\theta) = \log P(z_{0:T-1}, x_{0:T-1};
\theta)"/>, then the EM algorithm works by iteratively finding,</p>
<div class="math">
<p><img src="_images/math/cc1644290606e37e33de53fea3314f53554963b0.png" alt="P(x_{0:T-1} | z_{0:T-1}, \theta_i)"/></p>
</div><p>then by maximizing,</p>
<div class="math">
<p><img src="_images/math/f082e2288c736f7cb5f37186d1fb6084876311d8.png" alt="\theta_{i+1} = \arg\max_{\theta}
    \mathbb{E}_{x_{0:T-1}} [
        L(x_{0:T-1}, \theta)| z_{0:T-1}, \theta_i
    ]"/></p>
</div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>transition_matrices</strong> : [n_timesteps-1, n_dim_state, n_dim_state] or     [n_dim_state,n_dim_state] array-like</p>
<blockquote>
<div><p>Also known as <img class="math" src="_images/math/019e9892786e493964e145e7c5cf7b700314e53b.png" alt="A"/>.  state transition matrix between times t and
t+1 for t in [0...n_timesteps-2]</p>
</div></blockquote>
<p><strong>observation_matrices</strong> : [n_timesteps, n_dim_obs, n_dim_obs] or [n_dim_obs,     n_dim_obs] array-like</p>
<blockquote>
<div><p>Also known as <img class="math" src="_images/math/c3355896da590fc491a10150a50416687626d7cc.png" alt="C"/>.  observation matrix for times
[0...n_timesteps-1]</p>
</div></blockquote>
<p><strong>transition_covariance</strong> : [n_dim_state, n_dim_state] array-like</p>
<blockquote>
<div><p>Also known as <img class="math" src="_images/math/9866e3a998d628ba0941eb4fea0666ac391d149a.png" alt="Q"/>.  state transition covariance matrix for times
[0...n_timesteps-2]</p>
</div></blockquote>
<p><strong>observation_covariance</strong> : [n_dim_obs, n_dim_obs] array-like</p>
<blockquote>
<div><p>Also known as <img class="math" src="_images/math/eff43e84f8a3bcf7b6965f0a3248bc4d3a9d0cd4.png" alt="R"/>.  observation covariance matrix for times
[0...n_timesteps-1]</p>
</div></blockquote>
<p><strong>transition_offsets</strong> : [n_timesteps-1, n_dim_state] or [n_dim_state]     array-like</p>
<blockquote>
<div><p>Also known as <img class="math" src="_images/math/8136a7ef6a03334a7246df9097e5bcc31ba33fd2.png" alt="b"/>.  state offsets for times [0...n_timesteps-2]</p>
</div></blockquote>
<p><strong>observation_offsets</strong> : [n_timesteps, n_dim_obs] or [n_dim_obs] array-like</p>
<blockquote>
<div><p>Also known as <img class="math" src="_images/math/96ab646de7704969b91c76a214126b45f2b07b25.png" alt="d"/>.  observation offset for times
[0...n_timesteps-1]</p>
</div></blockquote>
<p><strong>initial_state_mean</strong> : [n_dim_state] array-like</p>
<blockquote>
<div><p>Also known as <img class="math" src="_images/math/7548319dd93c27598143e27cd09522e0c727ef4f.png" alt="\mu_0"/>. mean of initial state distribution</p>
</div></blockquote>
<p><strong>initial_state_covariance</strong> : [n_dim_state, n_dim_state] array-like</p>
<blockquote>
<div><p>Also known as <img class="math" src="_images/math/dcb56c9df837b86187e9c66311089e2e08be8308.png" alt="\Sigma_0"/>.  covariance of initial state
distribution</p>
</div></blockquote>
<p><strong>random_state</strong> : optional, numpy random state</p>
<blockquote>
<div><p>random number generator used in sampling</p>
</div></blockquote>
<p><strong>em_vars</strong> : optional, subset of [&#8216;transition_matrices&#8217;,     &#8216;observation_matrices&#8217;, &#8216;transition_offsets&#8217;, &#8216;observation_offsets&#8217;,     &#8216;transition_covariance&#8217;, &#8216;observation_covariance&#8217;, &#8216;initial_state_mean&#8217;,     &#8216;initial_state_covariance&#8217;] or &#8216;all&#8217;</p>
<blockquote>
<div><p>if <cite>em_vars</cite> is an iterable of strings only variables in <cite>em_vars</cite>
will be estimated using EM.  if <cite>em_vars</cite> == &#8216;all&#8217;, then all
variables will be estimated.</p>
</div></blockquote>
<p><strong>n_dim_state: optional, integer</strong> :</p>
<blockquote>
<div><p>the dimensionality of the state space. Only meaningful when you do not
specify initial values for <cite>transition_matrices</cite>, <cite>transition_offsets</cite>,
<cite>transition_covariance</cite>, <cite>initial_state_mean</cite>, or
<cite>initial_state_covariance</cite>.</p>
</div></blockquote>
<p><strong>n_dim_obs: optional, integer</strong> :</p>
<blockquote class="last">
<div><p>the dimensionality of the observation space. Only meaningful when you
do not specify initial values for <cite>observation_matrices</cite>,
<cite>observation_offsets</cite>, or <cite>observation_covariance</cite>.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pykalman.KalmanFilter.em" title="pykalman.KalmanFilter.em"><tt class="xref py py-obj docutils literal"><span class="pre">em</span></tt></a>(X[,&nbsp;y,&nbsp;n_iter,&nbsp;em_vars])</td>
<td>Apply the EM algorithm</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pykalman.KalmanFilter.filter" title="pykalman.KalmanFilter.filter"><tt class="xref py py-obj docutils literal"><span class="pre">filter</span></tt></a>(X)</td>
<td>Apply the Kalman Filter</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pykalman.KalmanFilter.filter_update" title="pykalman.KalmanFilter.filter_update"><tt class="xref py py-obj docutils literal"><span class="pre">filter_update</span></tt></a>(filtered_state_mean,&nbsp;...[,&nbsp;...])</td>
<td>Update a Kalman Filter state estimate</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pykalman.KalmanFilter.loglikelihood" title="pykalman.KalmanFilter.loglikelihood"><tt class="xref py py-obj docutils literal"><span class="pre">loglikelihood</span></tt></a>(X)</td>
<td>Calculate the log likelihood of all observations</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pykalman.KalmanFilter.sample" title="pykalman.KalmanFilter.sample"><tt class="xref py py-obj docutils literal"><span class="pre">sample</span></tt></a>(n_timesteps[,&nbsp;initial_state,&nbsp;...])</td>
<td>Sample a state sequence <img class="math" src="_images/math/793b0b50c62c31323d367d0cc7300197ca80f280.png" alt="n_{\text{timesteps}}"/> timesteps in length.</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pykalman.KalmanFilter.smooth" title="pykalman.KalmanFilter.smooth"><tt class="xref py py-obj docutils literal"><span class="pre">smooth</span></tt></a>(X)</td>
<td>Apply the Kalman Smoother</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pykalman.KalmanFilter.em">
<tt class="descname">em</tt><big>(</big><em>X</em>, <em>y=None</em>, <em>n_iter=10</em>, <em>em_vars=None</em><big>)</big><a class="headerlink" href="#pykalman.KalmanFilter.em" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the EM algorithm</p>
<p>Apply the EM algorithm to estimate all parameters specified by
<cite>em_vars</cite>.  Note that all variables estimated are assumed to be
constant for all time.  See <tt class="xref py py-func docutils literal"><span class="pre">_em()</span></tt> for details.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>X</strong> : [n_timesteps, n_dim_obs] array-like</p>
<blockquote>
<div><p>observations corresponding to times [0...n_timesteps-1].  If <cite>X</cite> is
a masked array and any of <cite>X[t]</cite>&#8216;s components is masked, then
<cite>X[t]</cite> will be treated as a missing observation.</p>
</div></blockquote>
<p><strong>n_iter</strong> : int, optional</p>
<blockquote>
<div><p>number of EM iterations to perform</p>
</div></blockquote>
<p><strong>em_vars</strong> : iterable of strings or &#8216;all&#8217;</p>
<blockquote class="last">
<div><p>variables to perform EM over.  Any variable not appearing here is
left untouched.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pykalman.KalmanFilter.filter">
<tt class="descname">filter</tt><big>(</big><em>X</em><big>)</big><a class="headerlink" href="#pykalman.KalmanFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the Kalman Filter</p>
<p>Apply the Kalman Filter to estimate the hidden state at time <img class="math" src="_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/>
for <img class="math" src="_images/math/6f7b86ed150ff57b9ae1aaebaaedb1fd871a134f.png" alt="t = [0...n_{\text{timesteps}}-1]"/> given observations up to
and including time <cite>t</cite>.  Observations are assumed to correspond to
times <img class="math" src="_images/math/01e323847af3dc5620c7d16eb6d1c949c4e54bf9.png" alt="[0...n_{\text{timesteps}}-1]"/>.  The output of this method
corresponding to time <img class="math" src="_images/math/886203f0d63798f1e50acd1c1162d0a89aa55e85.png" alt="n_{\text{timesteps}}-1"/> can be used in
<a class="reference internal" href="#pykalman.KalmanFilter.filter_update" title="pykalman.KalmanFilter.filter_update"><tt class="xref py py-func docutils literal"><span class="pre">KalmanFilter.filter_update()</span></tt></a> for online updating.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>X</strong> : [n_timesteps, n_dim_obs] array-like</p>
<blockquote>
<div><p>observations corresponding to times [0...n_timesteps-1].  If <cite>X</cite> is
a masked array and any of <cite>X[t]</cite> is masked, then <cite>X[t]</cite> will be
treated as a missing observation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>filtered_state_means</strong> : [n_timesteps, n_dim_state]</p>
<blockquote>
<div><p>mean of hidden state distributions for times [0...n_timesteps-1]
given observations up to and including the current time step</p>
</div></blockquote>
<p><strong>filtered_state_covariances</strong> : [n_timesteps, n_dim_state, n_dim_state]         array</p>
<blockquote class="last">
<div><p>covariance matrix of hidden state distributions for times
[0...n_timesteps-1] given observations up to and including the
current time step</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pykalman.KalmanFilter.filter_update">
<tt class="descname">filter_update</tt><big>(</big><em>filtered_state_mean</em>, <em>filtered_state_covariance</em>, <em>observation=None</em>, <em>transition_matrix=None</em>, <em>transition_offset=None</em>, <em>transition_covariance=None</em>, <em>observation_matrix=None</em>, <em>observation_offset=None</em>, <em>observation_covariance=None</em><big>)</big><a class="headerlink" href="#pykalman.KalmanFilter.filter_update" title="Permalink to this definition">¶</a></dt>
<dd><p>Update a Kalman Filter state estimate</p>
<p>Perform a one-step update to estimate the state at time <img class="math" src="_images/math/6698e583d6d03ec099c12e35add2e895252c49dd.png" alt="t+1"/>
give an observation at time <img class="math" src="_images/math/6698e583d6d03ec099c12e35add2e895252c49dd.png" alt="t+1"/> and the previous estimate for
time <img class="math" src="_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/> given observations from times <img class="math" src="_images/math/140e7dce824363846a48ef0b20cd48df4b99a567.png" alt="[0...t]"/>.  This
method is useful if one wants to track an object with streaming
observations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>filtered_state_mean</strong> : [n_dim_state] array</p>
<blockquote>
<div><p>mean estimate for state at time t given observations from times
[1...t]</p>
</div></blockquote>
<p><strong>filtered_state_covariance</strong> : [n_dim_state, n_dim_state] array</p>
<blockquote>
<div><p>covariance of estimate for state at time t given observations from
times [1...t]</p>
</div></blockquote>
<p><strong>observation</strong> : [n_dim_obs] array or None</p>
<blockquote>
<div><p>observation from time t+1.  If <cite>observation</cite> is a masked array and
any of <cite>observation</cite>&#8216;s components are masked or if <cite>observation</cite> is
None, then <cite>observation</cite> will be treated as a missing observation.</p>
</div></blockquote>
<p><strong>transition_matrix</strong> : optional, [n_dim_state, n_dim_state] array</p>
<blockquote>
<div><p>state transition matrix from time t to t+1.  If unspecified,
<cite>self.transition_matrices</cite> will be used.</p>
</div></blockquote>
<p><strong>transition_offset</strong> : optional, [n_dim_state] array</p>
<blockquote>
<div><p>state offset for transition from time t to t+1.  If unspecified,
<cite>self.transition_offset</cite> will be used.</p>
</div></blockquote>
<p><strong>transition_covariance</strong> : optional, [n_dim_state, n_dim_state] array</p>
<blockquote>
<div><p>state transition covariance from time t to t+1.  If unspecified,
<cite>self.transition_covariance</cite> will be used.</p>
</div></blockquote>
<p><strong>observation_matrix</strong> : optional, [n_dim_obs, n_dim_state] array</p>
<blockquote>
<div><p>observation matrix at time t+1.  If unspecified,
<cite>self.observation_matrices</cite> will be used.</p>
</div></blockquote>
<p><strong>observation_offset</strong> : optional, [n_dim_obs] array</p>
<blockquote>
<div><p>observation offset at time t+1.  If unspecified,
<cite>self.observation_offset</cite> will be used.</p>
</div></blockquote>
<p><strong>observation_covariance</strong> : optional, [n_dim_obs, n_dim_obs] array</p>
<blockquote>
<div><p>observation covariance at time t+1.  If unspecified,
<cite>self.observation_covariance</cite> will be used.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>next_filtered_state_mean</strong> : [n_dim_state] array</p>
<blockquote>
<div><p>mean estimate for state at time t+1 given observations from times
[1...t+1]</p>
</div></blockquote>
<p><strong>next_filtered_state_covariance</strong> : [n_dim_state, n_dim_state] array</p>
<blockquote class="last">
<div><p>covariance of estimate for state at time t+1 given observations
from times [1...t+1]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pykalman.KalmanFilter.loglikelihood">
<tt class="descname">loglikelihood</tt><big>(</big><em>X</em><big>)</big><a class="headerlink" href="#pykalman.KalmanFilter.loglikelihood" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the log likelihood of all observations</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>X</strong> : [n_timesteps, n_dim_obs] array</p>
<blockquote>
<div><p>observations for time steps [0...n_timesteps-1]</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>likelihood</strong> : float</p>
<blockquote class="last">
<div><p>likelihood of all observations</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pykalman.KalmanFilter.sample">
<tt class="descname">sample</tt><big>(</big><em>n_timesteps</em>, <em>initial_state=None</em>, <em>random_state=None</em><big>)</big><a class="headerlink" href="#pykalman.KalmanFilter.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample a state sequence <img class="math" src="_images/math/793b0b50c62c31323d367d0cc7300197ca80f280.png" alt="n_{\text{timesteps}}"/> timesteps in
length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>n_timesteps</strong> : int</p>
<blockquote>
<div><p>number of timesteps</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>states</strong> : [n_timesteps, n_dim_state] array</p>
<blockquote>
<div><p>hidden states corresponding to times [0...n_timesteps-1]</p>
</div></blockquote>
<p><strong>observations</strong> : [n_timesteps, n_dim_obs] array</p>
<blockquote class="last">
<div><p>observations corresponding to times [0...n_timesteps-1]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pykalman.KalmanFilter.smooth">
<tt class="descname">smooth</tt><big>(</big><em>X</em><big>)</big><a class="headerlink" href="#pykalman.KalmanFilter.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply the Kalman Smoother</p>
<p>Apply the Kalman Smoother to estimate the hidden state at time
<img class="math" src="_images/math/e0d2bf360290fd61d1c1557e763f2622363b3d35.png" alt="t"/> for <img class="math" src="_images/math/6f7b86ed150ff57b9ae1aaebaaedb1fd871a134f.png" alt="t = [0...n_{\text{timesteps}}-1]"/> given all
observations.  See <tt class="xref py py-func docutils literal"><span class="pre">_smooth()</span></tt> for more complex output</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>X</strong> : [n_timesteps, n_dim_obs] array-like</p>
<blockquote>
<div><p>observations corresponding to times [0...n_timesteps-1].  If <cite>X</cite> is
a masked array and any of <cite>X[t]</cite> is masked, then <cite>X[t]</cite> will be
treated as a missing observation.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>smoothed_state_means</strong> : [n_timesteps, n_dim_state]</p>
<blockquote>
<div><p>mean of hidden state distributions for times [0...n_timesteps-1]
given all observations</p>
</div></blockquote>
<p><strong>smoothed_state_covariances</strong> : [n_timesteps, n_dim_state]</p>
<blockquote class="last">
<div><p>covariances of hidden state distributions for times
[0...n_timesteps-1] given all observations</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="unscentedkalmanfilter">
<h3><a class="reference internal" href="#pykalman.UnscentedKalmanFilter" title="pykalman.UnscentedKalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">UnscentedKalmanFilter</span></tt></a><a class="headerlink" href="#unscentedkalmanfilter" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pykalman.UnscentedKalmanFilter">
<em class="property">class </em><tt class="descclassname">pykalman.</tt><tt class="descname">UnscentedKalmanFilter</tt><big>(</big><em>f</em>, <em>g</em>, <em>Q</em>, <em>R</em>, <em>mu_0</em>, <em>sigma_0</em>, <em>random_state=None</em><big>)</big><a class="headerlink" href="#pykalman.UnscentedKalmanFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the General (aka Augmented) Unscented Kalman Filter governed
by the following equations,</p>
<div class="math">
<p><img src="_images/math/fa9f931d2700772f97b54da1f426342b0c646cc2.png" alt="v_t       &amp;\sim \text{Normal}(0, Q)     \\
w_t       &amp;\sim \text{Normal}(0, R)     \\
x_{t+1}   &amp;= f_t(x_t, v_t)              \\
z_{t}     &amp;= g_t(x_t, w_t)"/></p>
</div><p>Notice that although the input noise to the state transition equation and
the observation equation are both normally distributed, any non-linear
transformation may be applied afterwards.  This allows for greater
generality, but at the expense of computational complexity.  The complexity
of <a class="reference internal" href="#pykalman.UnscentedKalmanFilter.filter" title="pykalman.UnscentedKalmanFilter.filter"><tt class="xref py py-class docutils literal"><span class="pre">UnscentedKalmanFilter.filter()</span></tt></a> is <img class="math" src="_images/math/a0004a7528f43bef140dbe75b2ef3c4c8d595cdd.png" alt="O(T(2n+m)^3)"/>
where <img class="math" src="_images/math/2554b6496c3b678897e9b060ef00aa9f0a7d7ece.png" alt="T"/> is the number of time steps, <img class="math" src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n"/> is the size of the
state space, and <img class="math" src="_images/math/f5047d1e0cbb50ec208923a22cd517c55100fa7b.png" alt="m"/> is the size of the observation space.</p>
<p>If your noise is simply additive, consider using the
<a class="reference internal" href="#pykalman.AdditiveUnscentedKalmanFilter" title="pykalman.AdditiveUnscentedKalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">AdditiveUnscentedKalmanFilter</span></tt></a></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>f</strong> : function or [T-1] array of functions</p>
<blockquote>
<div><p>f[t] is a function of the state and the transition noise at time t and
produces the state at time t+1</p>
</div></blockquote>
<p><strong>g</strong> : function or [T] array of functions</p>
<blockquote>
<div><p>g[t] is a function of the state and the observation noise at time t and
produces the observation at time t.</p>
</div></blockquote>
<p><strong>Q</strong> : [n_dim_state, n_dim_state] array</p>
<blockquote>
<div><p>transition noise covariance matrix</p>
</div></blockquote>
<p><strong>R</strong> : [n_dim_obs, n_dim_obs] array</p>
<blockquote>
<div><p>observation noise covariance matrix</p>
</div></blockquote>
<p><strong>mu_0</strong> : [n_dim_state] array</p>
<blockquote>
<div><p>mean of initial state distribution</p>
</div></blockquote>
<p><strong>sigma_0</strong> : [n_dim_state, n_dim_state] array</p>
<blockquote>
<div><p>covariance of initial state distribution</p>
</div></blockquote>
<p><strong>random_state</strong> : optional, int or RandomState</p>
<blockquote class="last">
<div><p>seed for random sample generation</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pykalman.UnscentedKalmanFilter.filter" title="pykalman.UnscentedKalmanFilter.filter"><tt class="xref py py-obj docutils literal"><span class="pre">filter</span></tt></a>(Z)</td>
<td>Run Unscented Kalman Filter</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pykalman.UnscentedKalmanFilter.sample" title="pykalman.UnscentedKalmanFilter.sample"><tt class="xref py py-obj docutils literal"><span class="pre">sample</span></tt></a>(T[,&nbsp;x_0])</td>
<td>Sample from model defined by the Unscented Kalman Filter</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pykalman.UnscentedKalmanFilter.smooth" title="pykalman.UnscentedKalmanFilter.smooth"><tt class="xref py py-obj docutils literal"><span class="pre">smooth</span></tt></a>(Z)</td>
<td>Run Unscented Kalman Smoother</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pykalman.UnscentedKalmanFilter.filter">
<tt class="descname">filter</tt><big>(</big><em>Z</em><big>)</big><a class="headerlink" href="#pykalman.UnscentedKalmanFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Run Unscented Kalman Filter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>Z</strong> : [T, n_dim_state] array</p>
<blockquote>
<div><p>Z[t] = observation at time t.  If Z is a masked array and any of
Z[t]&#8217;s elements are masked, the observation is assumed missing and
ignored.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>mu_filt</strong> : [T, n_dim_state] array</p>
<blockquote>
<div><p>mu_filt[t] = mean of state distribution at time t given
observations from times [0, t]</p>
</div></blockquote>
<p><strong>sigma_filt</strong> : [T, n_dim_state, n_dim_state] array</p>
<blockquote class="last">
<div><p>sigma_filt[t] = covariance of state distribution at time t given
observations from times [0, t]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pykalman.UnscentedKalmanFilter.sample">
<tt class="descname">sample</tt><big>(</big><em>T</em>, <em>x_0=None</em><big>)</big><a class="headerlink" href="#pykalman.UnscentedKalmanFilter.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from model defined by the Unscented Kalman Filter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>T</strong> : int</p>
<blockquote>
<div><p>number of time steps</p>
</div></blockquote>
<p><strong>x_0</strong> : optional, [n_dim_state] array</p>
<blockquote class="last">
<div><p>initial state.  If unspecified, will be sampled from initial state
distribution.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pykalman.UnscentedKalmanFilter.smooth">
<tt class="descname">smooth</tt><big>(</big><em>Z</em><big>)</big><a class="headerlink" href="#pykalman.UnscentedKalmanFilter.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Run Unscented Kalman Smoother</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>Z</strong> : [T, n_dim_state] array</p>
<blockquote>
<div><p>Z[t] = observation at time t.  If Z is a masked array and any of
Z[t]&#8217;s elements are masked, the observation is assumed missing and
ignored.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>mu_smooth</strong> : [T, n_dim_state] array</p>
<blockquote>
<div><p>mu_filt[t] = mean of state distribution at time t given
observations from times [0, T-1]</p>
</div></blockquote>
<p><strong>sigma_smooth</strong> : [T, n_dim_state, n_dim_state] array</p>
<blockquote class="last">
<div><p>sigma_filt[t] = covariance of state distribution at time t given
observations from times [0, T-1]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="additiveunscentedkalmanfilter">
<h3><a class="reference internal" href="#pykalman.AdditiveUnscentedKalmanFilter" title="pykalman.AdditiveUnscentedKalmanFilter"><tt class="xref py py-class docutils literal"><span class="pre">AdditiveUnscentedKalmanFilter</span></tt></a><a class="headerlink" href="#additiveunscentedkalmanfilter" title="Permalink to this headline">¶</a></h3>
<dl class="class">
<dt id="pykalman.AdditiveUnscentedKalmanFilter">
<em class="property">class </em><tt class="descclassname">pykalman.</tt><tt class="descname">AdditiveUnscentedKalmanFilter</tt><big>(</big><em>f</em>, <em>g</em>, <em>Q</em>, <em>R</em>, <em>mu_0</em>, <em>sigma_0</em>, <em>random_state=None</em><big>)</big><a class="headerlink" href="#pykalman.AdditiveUnscentedKalmanFilter" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the Unscented Kalman Filter with additive noise.
Observations are assumed to be generated from the following process,</p>
<div class="math">
<p><img src="_images/math/0741fd6adfcc898bf810cc68e31767e07d781476.png" alt="v_t       &amp;\sim \text{Normal}(0, Q)     \\
w_t       &amp;\sim \text{Normal}(0, R)     \\
x_{t+1}   &amp;= f_t(x_t) + v_t             \\
z_{t}     &amp;= g_t(x_t) + w_t"/></p>
</div><p>While less general the general-noise Unscented Kalman Filter, the Additive
version is more computationally efficient with complexity <img class="math" src="_images/math/2c2c6395ae022d7e6ac9bc6af9b7969e619ca9c7.png" alt="O(Tn^3)"/>
where <img class="math" src="_images/math/2554b6496c3b678897e9b060ef00aa9f0a7d7ece.png" alt="T"/> is the number of time steps and <img class="math" src="_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n"/> is the size of
the state space.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>f</strong> : function or [T-1] array of functions</p>
<blockquote>
<div><p>f[t] is a function of the state at time t and produces the state at
time t+1</p>
</div></blockquote>
<p><strong>g</strong> : function or [T] array of functions</p>
<blockquote>
<div><p>g[t] is a function of the state at time t and produces the observation
at time t</p>
</div></blockquote>
<p><strong>Q</strong> : [n_dim_state, n_dim_state] array</p>
<blockquote>
<div><p>transition noise covariance matrix</p>
</div></blockquote>
<p><strong>R</strong> : [n_dim_obs, n_dim_obs] array</p>
<blockquote>
<div><p>observation noise covariance matrix</p>
</div></blockquote>
<p><strong>mu_0</strong> : [n_dim_state] array</p>
<blockquote>
<div><p>mean of initial state distribution</p>
</div></blockquote>
<p><strong>sigma_0</strong> : [n_dim_state, n_dim_state] array</p>
<blockquote>
<div><p>covariance of initial state distribution</p>
</div></blockquote>
<p><strong>random_state</strong> : optional, int or RandomState</p>
<blockquote class="last">
<div><p>seed for random sample generation</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table border="1" class="longtable docutils">
<colgroup>
<col width="10%" />
<col width="90%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td><a class="reference internal" href="#pykalman.AdditiveUnscentedKalmanFilter.filter" title="pykalman.AdditiveUnscentedKalmanFilter.filter"><tt class="xref py py-obj docutils literal"><span class="pre">filter</span></tt></a>(Z)</td>
<td>Run Unscented Kalman Filter</td>
</tr>
<tr class="row-even"><td><a class="reference internal" href="#pykalman.AdditiveUnscentedKalmanFilter.sample" title="pykalman.AdditiveUnscentedKalmanFilter.sample"><tt class="xref py py-obj docutils literal"><span class="pre">sample</span></tt></a>(T[,&nbsp;x_0])</td>
<td>Sample from model defined by the Unscented Kalman Filter</td>
</tr>
<tr class="row-odd"><td><a class="reference internal" href="#pykalman.AdditiveUnscentedKalmanFilter.smooth" title="pykalman.AdditiveUnscentedKalmanFilter.smooth"><tt class="xref py py-obj docutils literal"><span class="pre">smooth</span></tt></a>(Z)</td>
<td>Run Unscented Kalman Smoother</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="pykalman.AdditiveUnscentedKalmanFilter.filter">
<tt class="descname">filter</tt><big>(</big><em>Z</em><big>)</big><a class="headerlink" href="#pykalman.AdditiveUnscentedKalmanFilter.filter" title="Permalink to this definition">¶</a></dt>
<dd><p>Run Unscented Kalman Filter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>Z</strong> : [T, n_dim_state] array</p>
<blockquote>
<div><p>Z[t] = observation at time t.  If Z is a masked array and any of
Z[t]&#8217;s elements are masked, the observation is assumed missing and
ignored.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>mu_filt</strong> : [T, n_dim_state] array</p>
<blockquote>
<div><p>mu_filt[t] = mean of state distribution at time t given
observations from times [0, t]</p>
</div></blockquote>
<p><strong>sigma_filt</strong> : [T, n_dim_state, n_dim_state] array</p>
<blockquote class="last">
<div><p>sigma_filt[t] = covariance of state distribution at time t given
observations from times [0, t]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pykalman.AdditiveUnscentedKalmanFilter.sample">
<tt class="descname">sample</tt><big>(</big><em>T</em>, <em>x_0=None</em><big>)</big><a class="headerlink" href="#pykalman.AdditiveUnscentedKalmanFilter.sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Sample from model defined by the Unscented Kalman Filter</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>T</strong> : int</p>
<blockquote>
<div><p>number of time steps</p>
</div></blockquote>
<p><strong>x_0</strong> : optional, [n_dim_state] array</p>
<blockquote class="last">
<div><p>initial state.  If unspecified, will be sampled from initial state
distribution.</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="pykalman.AdditiveUnscentedKalmanFilter.smooth">
<tt class="descname">smooth</tt><big>(</big><em>Z</em><big>)</big><a class="headerlink" href="#pykalman.AdditiveUnscentedKalmanFilter.smooth" title="Permalink to this definition">¶</a></dt>
<dd><p>Run Unscented Kalman Smoother</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters :</th><td class="field-body"><p class="first"><strong>Z</strong> : [T, n_dim_state] array</p>
<blockquote>
<div><p>Z[t] = observation at time t.  If Z is a masked array and any of
Z[t]&#8217;s elements are masked, the observation is assumed missing and
ignored.</p>
</div></blockquote>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns :</th><td class="field-body"><p class="first"><strong>mu_smooth</strong> : [T, n_dim_state] array</p>
<blockquote>
<div><p>mu_filt[t] = mean of state distribution at time t given
observations from times [0, T-1]</p>
</div></blockquote>
<p><strong>sigma_smooth</strong> : [T, n_dim_state, n_dim_state] array</p>
<blockquote class="last">
<div><p>sigma_filt[t] = covariance of state distribution at time t given
observations from times [0, T-1]</p>
</div></blockquote>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="#">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">pykalman</a><ul>
<li><a class="reference internal" href="#installation">Installation</a></li>
<li><a class="reference internal" href="#user-s-guide">User&#8217;s Guide</a><ul>
<li><a class="reference internal" href="#basic-usage">Basic Usage</a><ul>
<li><a class="reference internal" href="#choosing-parameters">Choosing Parameters</a></li>
<li><a class="reference internal" href="#inferring-states">Inferring States</a></li>
<li><a class="reference internal" href="#optimizing-parameters">Optimizing Parameters</a></li>
<li><a class="reference internal" href="#missing-measurements">Missing Measurements</a></li>
</ul>
</li>
<li><a class="reference internal" href="#mathematical-formulation">Mathematical Formulation</a></li>
</ul>
</li>
<li><a class="reference internal" href="#class-reference">Class Reference</a><ul>
<li><a class="reference internal" href="#kalmanfilter"><tt class="docutils literal"><span class="pre">KalmanFilter</span></tt></a><ul>
</ul>
</li>
<li><a class="reference internal" href="#unscentedkalmanfilter"><tt class="docutils literal"><span class="pre">UnscentedKalmanFilter</span></tt></a><ul>
</ul>
</li>
<li><a class="reference internal" href="#additiveunscentedkalmanfilter"><tt class="docutils literal"><span class="pre">AdditiveUnscentedKalmanFilter</span></tt></a><ul>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>

  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="_sources/index.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li><a href="#">pykalman 0.9.0 documentation</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Daniel Duckworth.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>